/* 线性表：元素间存在线性的前后关系 */
/* 数组：数据在内存中连续存储 
     优点：
       随机访问O(1)
       尾部增删O(1)
       相邻元素访问便利
     缺点：
       非尾部增删
       无序搜索
       容量分配 */
/* 链表：数据在内存中独立存储
     优点：
       分散存储，内存利用率高
       元素增删(但搜索元素效率较低)
     缺点：
       额外占用存储空间
       链式访问，效率较低 */
/* 栈：数据先进后出 */
/* 队列：数据先进先出 */
/* 堆：特殊的完全二叉树，父节点与子节点满足特定的比较关系，一般基于线性表实现 */
/* 优先级队列：特殊的队列，元素根据其优先级顺序出队，一般基于堆实现 */

/* 树状表 */
/* 树：数据结构呈现层次化的嵌套，每个数据节点与其下一层的某些数据数据保持“一对多”的树形关系
   二叉树：每个节点最多存在两个子树
   满二叉树：除叶子节点外的任意节点都拥有两个子树
   完全二叉树：特殊的满二叉树，最下层节点从左往右连续不间断 */
/* 二叉搜索树BST：任意节点满足不小于左子树任意节点，且不大于右子树任意节点，也称二叉排序/查找树 */
/* 平衡二叉搜索树：BST的改进，具有自平衡机制
     任意节点满足左子树与右子树高度差不大于1
     能够避免二叉树向链表退化，维持搜索效率为O(logn) */
/* AVL树：严格平衡的BST
     插入新节点时最多引起两次旋转操作
     删除节点最多引起O(logn)复杂度的旋转操作 */
/* Rb树：非严格平衡的BST，通过染色机制限制树近似平衡，不会过度倾斜
     特征：
       1.每个节点拥有颜色属性，为红色或黑色
       2.根节点和空节点为黑色
       3.不能出现连续红色节点
       4.从根节点到每个叶子节点的简单路径上的黑色节点数量相同(包括空节点)
         (最长路径的长度 最多为 最短路径长度的 两倍)
     插入新节点时最多引起两次旋转操作
     删除节点时最多引起三次旋转操作 */
/* B树:绝对平衡的m叉树
     (m阶)特征：
       1.每个节点最多拥有m个子树
       2.非根非叶子节点至少拥有⌈m/2⌉个子树
       3.非根节点内元素的个数为满足⌊m/2⌋<=n<=m-1
     子树的数量永远比元素数量加一，子树与元素满足排序树的关系
       例如2-3-4树，最多3个元素，4个子树，结构为：
            e1    e2    e3
           /  \  /  \  /  \
         t1    t2    t3    t4
     当节点内拥有m个元素时，将其拆分为左子树，中间元素，右子树
       中间元素向上加入到父节点，并将两个子树更新到父节点中
       父节点以此类推，例如下面t2子树产生了拆分，ne2元素加入该节点
       若该树为3阶B树，则该节点也拆分，ne2继续向上加入父节点
           e1    e2             e1     ne2     e2
          /  \  /  \     ->    /  \   /   \   /  \
         t1   t2    t3        t1   nt2     nt3    t3
     当节点内元素数量不足时，向紧邻的兄弟节点提取一个节点(父节点中对应元素旋转)
       或与紧邻的兄弟节点合并(包括父节点中对应的元素)，父节点以此类推
     应用场景：索引系统，如数据库
     优势：计算机系统采用分块/分页的空间策略，利用高阶的B树，能够显著减少磁盘IO次数 */
/* B+树：B树的变体
     特征：
       1.只有叶子节点包含key和value的完整信息，且有序排列
       2.非叶子节点仅包含key的信息，用于索引的目标叶子节点
     应用场景：索引系统
     优势：
       非叶子节点中不包含value信息，相同数量的元素下，占用的空间更小
       相同的空间占用下，B+树可以更加高阶，进一步减少了磁盘IO次数
       查询效率更加稳定
       元素有序存储 */
/* B*树：B+树的变体
     特征：非叶子节点拥有一个指针指向兄弟节点
     当节点内元素达到m时，可以将元素移动给兄弟节点(父节点中对应元素旋转)
     若兄弟节点无法容纳新元素，则各抽取1/3的元素，并在在两者之间创建新节点
     优势：减少拆分节点的次数，提高空间使用率，节点最低利用率从1/2提升到2/3 */
/* 哈夫曼树：*/

/* 哈希表：元素散列存储
     使用关键字 通过哈希函数映射到 对应元素在哈希表内的存储地址
     优势：查询、插入、删除等操作的效率近似于O(1)
     劣势：空间利用率低，一般仅有50%
     哈希函数设计：
       1.结果唯一
       2.映射地址结果尽可能均匀，避免哈希冲突
       3.计算简单
       4.输入的微小变化在输出中被放大
     负载因子：存储元素数/哈希表尺寸
       负载因子低意味着哈希表内空位充裕，冲突概率低，性能高
       负载因子高意味着哈希表即将被占满，冲突概率剧增，链表或探测距离变大，性能下降
       当负载因子达到特定阈值，需要对哈希表扩容，即rehash
     常用哈希(可混合使用)：
       1.直接定址：使用关键字的线性映射
       2.数字分析：分析关键字的规律
       3.平方取中：关键字平方后取中间部分数字序列
       4.折叠法
       5.除法取余法：对固定值(一般取素数，降低哈希冲突概率)取余
       6.字符串哈希
       7.加密算法
     哈希冲突处理：
       1.链地址：链表存储哈希值相同的关键字对应的元素
           查找和删除的效率有所降低，进一步增加空间开销
           哈希冲突只在链表内产生影响
       2.开放地址：从冲突地址开始往后(或前后)寻找空闲地址
           不增加空间开销，但操作复杂，尤其是删除操作
           哈希冲突影响后续插入地址，可能导致元素聚集
           1)线性探测：hash+n；实现简单，但易产生聚集
           2)二次探测：hash+n^2；减少聚集，但可能无法探测所有地址
           3)双重哈希：hash+n*hash2；更加均匀，但计算复杂 */
/* 一致性哈希：
     在分布式方案中，良好的哈希方案应具有良好的单调性
       即分布式节点数量的变动不会导致大量的用户连接到新节点
     将分布式节点映射到哈希值域中，
       根据用户的哈希映射向上/下搜索最近的节点连接
       其中，哈希值域逻辑首尾相连 */

/* 位图：用一个bit值表示元素是否存在 */
/* bloom过滤器：哈希+位图
     利用键值通过多个哈希得到位图中的多个bit位
       并将这些位置1，表示新增元素
     在搜索时所有bit位均为1，表示 可能 存在该元素
       任意bit位为0，则 一定 不存在该元素
     优势：弥补了哈希表和位图的缺陷，兼顾时间和空间
     问题：
       只能执行增加和搜索，不能执行删除操作
       搜索结果为真并不可靠 */
